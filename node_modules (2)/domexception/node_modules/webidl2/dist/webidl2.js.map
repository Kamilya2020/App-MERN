{"version":3,"sources":["webpack://WebIDL2/webpack/universalModuleDefinition","webpack://WebIDL2/./lib/error.js","webpack://WebIDL2/./lib/productions/base.js","webpack://WebIDL2/./lib/validators/helpers.js","webpack://WebIDL2/./lib/productions/array-base.js","webpack://WebIDL2/./lib/productions/token.js","webpack://WebIDL2/./lib/productions/extended-attributes.js","webpack://WebIDL2/./lib/productions/type.js","webpack://WebIDL2/./lib/productions/default.js","webpack://WebIDL2/./lib/productions/argument.js","webpack://WebIDL2/./lib/productions/operation.js","webpack://WebIDL2/./lib/productions/attribute.js","webpack://WebIDL2/./lib/productions/helpers.js","webpack://WebIDL2/./lib/tokeniser.js","webpack://WebIDL2/./lib/productions/enum.js","webpack://WebIDL2/./lib/productions/includes.js","webpack://WebIDL2/./lib/productions/typedef.js","webpack://WebIDL2/./lib/productions/callback.js","webpack://WebIDL2/./lib/productions/container.js","webpack://WebIDL2/./lib/productions/constant.js","webpack://WebIDL2/./lib/productions/iterable.js","webpack://WebIDL2/./lib/productions/constructor.js","webpack://WebIDL2/./lib/productions/interface.js","webpack://WebIDL2/./lib/validators/interface.js","webpack://WebIDL2/./lib/productions/mixin.js","webpack://WebIDL2/./lib/productions/field.js","webpack://WebIDL2/./lib/productions/dictionary.js","webpack://WebIDL2/./lib/productions/namespace.js","webpack://WebIDL2/./lib/productions/callback-interface.js","webpack://WebIDL2/./lib/webidl2.js","webpack://WebIDL2/./lib/writer.js","webpack://WebIDL2/./lib/validator.js","webpack://WebIDL2/webpack/bootstrap","webpack://WebIDL2/webpack/startup","webpack://WebIDL2/webpack/runtime/define property getters","webpack://WebIDL2/webpack/runtime/hasOwnProperty shorthand","webpack://WebIDL2/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","error","source","position","current","message","kind","level","autofix","ruleName","sliceTokens","count","slice","Math","max","tokensToText","inputs","precedes","text","map","t","trivia","value","join","nextToken","type","length","line","precedingLastLine","splitted","split","lastLine","subsequentTokens","subsequentText","sourceContext","repeat","contextType","context","name","partial","node","hierarchy","parent","unshift","n","base","target","result","appendIfExist","contextAsText","bareMessage","sourceName","input","tokens","syntaxError","validationError","token","options","index","Base","Object","defineProperties","writable","json","undefined","inheritance","proto","prototype","descMap","getOwnPropertyDescriptors","key","entries","enumerable","get","getPrototypeOf","idlTypeIncludesDictionary","idlType","defs","useNullableInner","union","def","unique","typedefIncludesDictionary","cache","has","set","reference","dictionary","nullable","subtype","dictionaryIncludesRequiredField","dict","members","some","field","required","superdict","ArrayBase","Array","super","Token","tokeniser","consume","tokenName","list","parser","listName","extAttrValueSyntax","renamedLegacies","Map","extAttrListItems","syntax","toks","ExtendedAttributeParameters","assign","ret","autoParenter","secondaryName","open","rhsIsList","argument_list","close","hasRhs","SimpleExtendedAttribute","params","parse","defineProperty","rhsType","extAttr","arg","arguments","validate","ExtendedAttributes","push","probe","type_suffix","obj","single_type","typeName","Type","return_type","type_with_extended_attributes","keyType","stringTypes","keyIdlType","separator","valueType","generic_type","primitive_type","typeNameKeywords","generic","typ","or","union_type","extAttrs","Boolean","prefix","postfix","filter","typedef","targetToken","Default","const_value","expression","const_data","negative","Argument","start_position","optional","variadic","argumentNameKeywords","default","unconsume","autofixOptionalDictionaryDefaultValue","indexOf","a","isLastRequiredArgument","firstToken","getFirstToken","Tokeniser","Operation","special","regular","termination","includes","argument","Attribute","noInherit","readonly","identifier","startsWith","allowDangler","first","items","item","num_type","integer_type","decimal_type","voidToken","stringifier","getLastIndentation","str","lines","match","autofixAddExposedWindow","exposed","existing","test","data","values","sort","x","y","Proxy","p","isArray","tokenRe","nonRegexTerminals","concat","punctuations","reserved","idl","lastCharIndex","nextChar","charAt","attemptTokenMatch","noFlushTrivia","currentTrivia","pop","lastIndex","WebIDLParseError","punctuation","Error","re","exec","tokenise","candidates","EnumValue","Enum","Includes","mixin","Typedef","CallbackFunction","Container","instance","inheritable","allowedMembers","colon","ea","mem","args","member","Constant","IterableLike","async","secondTypeRequired","secondTypeAllowed","argumentAllowed","argsOpen","argsClose","Constructor","static_member","Interface","every","oldConstructors","constructor","autofixConstructor","factoryFunctions","named","constructors","i","opNames","Set","getOperations","op","partials","mixins","mixinMap","ext","additions","forEachExtension","addition","add","existings","checkInterfaceMemberDuplication","interfaceDef","constructorExtAttr","indentation","memberIndent","parentTrivia","indentCh","getMemberIndentation","constructorOp","existingIndex","array","predicate","reverse","findIndex","findLastIndex","m","splice","removed","trim","Mixin","Field","Dictionary","Namespace","CallbackInterface","callback","parseByTokens","interface_","opts","definition","res","eof","concrete","definitions","noop","templates","wrap","nameless","extendedAttribute","extendedAttributeReference","write","ast","ts","raw","unescaped","wrapper","reference_token","name_token","type_body","it","ref","extended_attributes","default_","extended_attribute_listitem","make_ext_at","id","endsWith","eats","container","inh","iterate","iterable_like","table","interface","namespace","operation","body","attribute","const","enum","v","iterable","maplike","setlike","things","results","thing","dispatch","getMixinMap","all","include","validateIterable","duplicates","WeakMap","groupDefinitions","dup","checkDuplicatedNames","flat","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","o","prop","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"webidl2.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebIDL2\"] = factory();\n\telse\n\t\troot[\"WebIDL2\"] = factory();\n})(this, function() {\nreturn ","/**\n * @param {string} text\n */\nfunction lastLine(text) {\n  const splitted = text.split(\"\\n\");\n  return splitted[splitted.length - 1];\n}\n\nfunction appendIfExist(base, target) {\n  let result = base;\n  if (target) {\n    result += ` ${target}`;\n  }\n  return result;\n}\n\nfunction contextAsText(node) {\n  const hierarchy = [node];\n  while (node && node.parent) {\n    const { parent } = node;\n    hierarchy.unshift(parent);\n    node = parent;\n  }\n  return hierarchy.map(n => appendIfExist(n.type, n.name)).join(\" -> \");\n}\n\n/**\n * @typedef {object} WebIDL2ErrorOptions\n * @property {\"error\" | \"warning\"} [level]\n * @property {Function} [autofix]\n *\n * @param {string} message error message\n * @param {\"Syntax\" | \"Validation\"} kind error type\n * @param {WebIDL2ErrorOptions} [options]\n */\nfunction error(source, position, current, message, kind, { level = \"error\", autofix, ruleName } = {}) {\n  /**\n   * @param {number} count\n   */\n  function sliceTokens(count) {\n    return count > 0 ?\n      source.slice(position, position + count) :\n      source.slice(Math.max(position + count, 0), position);\n  }\n\n  function tokensToText(inputs, { precedes } = {}) {\n    const text = inputs.map(t => t.trivia + t.value).join(\"\");\n    const nextToken = source[position];\n    if (nextToken.type === \"eof\") {\n      return text;\n    }\n    if (precedes) {\n      return text + nextToken.trivia;\n    }\n    return text.slice(nextToken.trivia.length);\n  }\n\n  const maxTokens = 5; // arbitrary but works well enough\n  const line =\n    source[position].type !== \"eof\" ? source[position].line :\n    source.length > 1 ? source[position - 1].line :\n    1;\n\n  const precedingLastLine = lastLine(\n    tokensToText(sliceTokens(-maxTokens), { precedes: true })\n  );\n\n  const subsequentTokens = sliceTokens(maxTokens);\n  const subsequentText = tokensToText(subsequentTokens);\n  const subsequentFirstLine = subsequentText.split(\"\\n\")[0];\n\n  const spaced = \" \".repeat(precedingLastLine.length) + \"^\";\n  const sourceContext = precedingLastLine + subsequentFirstLine + \"\\n\" + spaced;\n\n  const contextType = kind === \"Syntax\" ? \"since\" : \"inside\";\n  const inSourceName = source.name ? ` in ${source.name}` : \"\";\n  const grammaticalContext = (current && current.name) ? `, ${contextType} \\`${current.partial ? \"partial \" : \"\"}${contextAsText(current)}\\`` : \"\";\n  const context = `${kind} error at line ${line}${inSourceName}${grammaticalContext}:\\n${sourceContext}`;\n  return {\n    message: `${context} ${message}`,\n    bareMessage: message,\n    context,\n    line,\n    sourceName: source.name,\n    level,\n    ruleName,\n    autofix,\n    input: subsequentText,\n    tokens: subsequentTokens\n  };\n}\n\n/**\n * @param {string} message error message\n */\nexport function syntaxError(source, position, current, message) {\n  return error(source, position, current, message, \"Syntax\");\n}\n\n/**\n * @param {string} message error message\n * @param {WebIDL2ErrorOptions} [options]\n */\nexport function validationError(token, current, ruleName, message, options = {}) {\n  options.ruleName = ruleName;\n  return error(current.source, token.index, current, message, \"Validation\", options);\n}\n","// @ts-check\n\nexport class Base {\n  /**\n   * @param {object} initializer\n   * @param {Base[\"source\"]} initializer.source\n   * @param {Base[\"tokens\"]} initializer.tokens\n   */\n  constructor({ source, tokens }) {\n    Object.defineProperties(this, {\n      source: { value: source },\n      tokens: { value: tokens, writable: true },\n      parent: { value: null, writable: true },\n      this: { value: this } // useful when escaping from proxy\n    });\n  }\n\n  toJSON() {\n    const json = { type: undefined, name: undefined, inheritance: undefined };\n    let proto = this;\n    while (proto !== Object.prototype) {\n      const descMap = Object.getOwnPropertyDescriptors(proto);\n      for (const [key, value] of Object.entries(descMap)) {\n        if (value.enumerable || value.get) {\n          // @ts-ignore - allow indexing here\n          json[key] = this[key];\n        }\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return json;\n  }\n}\n","// @ts-check\n\n/**\n * @typedef {import(\"../productions/dictionary.js\").Dictionary} Dictionary\n *\n * @param {*} idlType\n * @param {import(\"../validator.js\").Definitions} defs\n * @param {object} [options]\n * @param {boolean} [options.useNullableInner] use when the input idlType is nullable and you want to use its inner type\n * @return {{ reference: *, dictionary: Dictionary }} the type reference that ultimately includes dictionary.\n */\nexport function idlTypeIncludesDictionary(idlType, defs, { useNullableInner } = {}) {\n  if (!idlType.union) {\n    const def = defs.unique.get(idlType.idlType);\n    if (!def) {\n      return;\n    }\n    if (def.type === \"typedef\") {\n      const { typedefIncludesDictionary } = defs.cache;\n      if (typedefIncludesDictionary.has(def)) {\n        // Note that this also halts when it met indeterminate state\n        // to prevent infinite recursion\n        return typedefIncludesDictionary.get(def);\n      }\n      defs.cache.typedefIncludesDictionary.set(def, undefined); // indeterminate state\n      const result = idlTypeIncludesDictionary(def.idlType, defs);\n      defs.cache.typedefIncludesDictionary.set(def, result);\n      if (result) {\n        return {\n          reference: idlType,\n          dictionary: result.dictionary\n        };\n      }\n    }\n    if (def.type === \"dictionary\" && (useNullableInner || !idlType.nullable)) {\n      return {\n        reference: idlType,\n        dictionary: def\n      };\n    }\n  }\n  for (const subtype of idlType.subtype) {\n    const result = idlTypeIncludesDictionary(subtype, defs);\n    if (result) {\n      if (subtype.union) {\n        return result;\n      }\n      return {\n        reference: subtype,\n        dictionary: result.dictionary\n      };\n    }\n  }\n}\n\n/**\n * @param {*} dict dictionary type\n * @param {import(\"../validator.js\").Definitions} defs\n * @return {boolean}\n */\nexport function dictionaryIncludesRequiredField(dict, defs) {\n  if (defs.cache.dictionaryIncludesRequiredField.has(dict)) {\n    return defs.cache.dictionaryIncludesRequiredField.get(dict);\n  }\n  // Set cached result to indeterminate to short-circuit circular definitions.\n  // The final result will be updated to true or false.\n  defs.cache.dictionaryIncludesRequiredField.set(dict, undefined);\n  let result = dict.members.some(field => field.required);\n  if (!result && dict.inheritance) {\n    const superdict = defs.unique.get(dict.inheritance);\n    if (!superdict) {\n      // Assume required members in the supertype if it is unknown.\n      result = true;\n    } else if (dictionaryIncludesRequiredField(superdict, defs)) {\n      result = true;\n    }\n  }\n  defs.cache.dictionaryIncludesRequiredField.set(dict, result);\n  return result;\n}\n","// @ts-check\n\nexport class ArrayBase extends Array {\n  constructor({ source, tokens }) {\n    super();\n    Object.defineProperties(this, {\n      source: { value: source },\n      tokens: { value: tokens },\n      parent: { value: null, writable: true }\n    });\n  }\n}\n","// @ts-check\n\nimport { Base } from \"./base.js\";\nimport { unescape } from \"./helpers.js\";\n\nexport class Token extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   * @param {string} type\n   */\n  static parser(tokeniser, type) {\n    return () => {\n      const value = tokeniser.consume(type);\n      if (value) {\n        return new Token({ source: tokeniser.source, tokens: { value } });\n      }\n    };\n  }\n\n  get value() {\n    return unescape(this.tokens.value.value);\n  }\n}\n","import { Base } from \"./base.js\";\nimport { ArrayBase } from \"./array-base.js\";\nimport { Token } from \"./token.js\";\nimport { list, argument_list, autoParenter, unescape } from \"./helpers.js\";\nimport { validationError } from \"../error.js\";\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} tokenName\n */\nfunction tokens(tokeniser, tokenName) {\n  return list(tokeniser, {\n    parser: Token.parser(tokeniser, tokenName),\n    listName: tokenName + \" list\"\n  });\n}\n\nconst extAttrValueSyntax = [\"identifier\", \"decimal\", \"integer\", \"string\"];\n\nconst shouldBeLegacyPrefixed = [\n  \"NoInterfaceObject\",\n  \"LenientSetter\",\n  \"LenientThis\",\n  \"TreatNonObjectAsNull\",\n  \"Unforgeable\",\n];\n\nconst renamedLegacies = new Map([\n  ...shouldBeLegacyPrefixed.map(name => [name, `Legacy${name}`]),\n  [\"NamedConstructor\", \"LegacyFactoryFunction\"],\n  [\"OverrideBuiltins\", \"LegacyOverrideBuiltIns\"],\n  [\"TreatNullAs\", \"LegacyNullToEmptyString\"],\n]);\n\n/**\n * This will allow a set of extended attribute values to be parsed.\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nfunction extAttrListItems(tokeniser) {\n  for (const syntax of extAttrValueSyntax) {\n    const toks = tokens(tokeniser, syntax);\n    if (toks.length) {\n      return toks;\n    }\n  }\n  tokeniser.error(`Expected identifiers, strings, decimals, or integers but none found`);\n}\n\n\nclass ExtendedAttributeParameters extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const tokens = { assign: tokeniser.consume(\"=\") };\n    const ret = autoParenter(new ExtendedAttributeParameters({ source: tokeniser.source, tokens }));\n    if (tokens.assign) {\n      tokens.secondaryName = tokeniser.consume(...extAttrValueSyntax);\n    }\n    tokens.open = tokeniser.consume(\"(\");\n    if (tokens.open) {\n      ret.list = ret.rhsIsList ?\n        // [Exposed=(Window,Worker)]\n        extAttrListItems(tokeniser) :\n        // [LegacyFactoryFunction=Audio(DOMString src)] or [Constructor(DOMString str)]\n        argument_list(tokeniser);\n      tokens.close = tokeniser.consume(\")\") || tokeniser.error(\"Unexpected token in extended attribute argument list\");\n    } else if (ret.hasRhs && !tokens.secondaryName) {\n      tokeniser.error(\"No right hand side to extended attribute assignment\");\n    }\n    return ret.this;\n  }\n\n  get rhsIsList() {\n    return this.tokens.assign && !this.tokens.secondaryName;\n  }\n\n  get rhsType() {\n    if (this.rhsIsList) {\n      return this.list[0].tokens.value.type + \"-list\";\n    }\n    if (this.tokens.secondaryName) {\n      return this.tokens.secondaryName.type;\n    }\n    return null;\n  }\n}\n\nexport class SimpleExtendedAttribute extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const name = tokeniser.consume(\"identifier\");\n    if (name) {\n      return new SimpleExtendedAttribute({\n        source: tokeniser.source,\n        tokens: { name },\n        params: ExtendedAttributeParameters.parse(tokeniser)\n      });\n    }\n  }\n\n  constructor({ source, tokens, params }) {\n    super({ source, tokens });\n    params.parent = this;\n    Object.defineProperty(this, \"params\", { value: params });\n  }\n\n  get type() {\n    return \"extended-attribute\";\n  }\n  get name() {\n    return this.tokens.name.value;\n  }\n  get rhs() {\n    const { rhsType: type, tokens, list } = this.params;\n    if (!type) {\n      return null;\n    }\n    const value = this.params.rhsIsList ? list : unescape(tokens.secondaryName.value);\n    return { type, value };\n  }\n  get arguments() {\n    const { rhsIsList, list } = this.params;\n    if (!list || rhsIsList) {\n      return [];\n    }\n    return list;\n  }\n\n  *validate(defs) {\n    const { name } = this;\n    if (name === \"LegacyNoInterfaceObject\") {\n      const message = `\\`[LegacyNoInterfaceObject]\\` extended attribute is an \\\nundesirable feature that may be removed from Web IDL in the future. Refer to the \\\n[relevant upstream PR](https://github.com/heycam/webidl/pull/609) for more \\\ninformation.`;\n      yield validationError(this.tokens.name, this, \"no-nointerfaceobject\", message, { level: \"warning\" });\n    } else if (renamedLegacies.has(name)) {\n      const message = `\\`[${name}]\\` extended attribute is a legacy feature \\\nthat is now renamed to \\`[${renamedLegacies.get(name)}]\\`. Refer to the \\\n[relevant upstream PR](https://github.com/heycam/webidl/pull/870) for more \\\ninformation.`;\n      yield validationError(this.tokens.name, this, \"renamed-legacy\", message, {\n        level: \"warning\",\n        autofix: renameLegacyExtendedAttribute(this)\n      });\n    }\n    for (const arg of this.arguments) {\n      yield* arg.validate(defs);\n    }\n  }\n}\n\n/**\n * @param {SimpleExtendedAttribute} extAttr\n */\nfunction renameLegacyExtendedAttribute(extAttr) {\n  return () => {\n    const { name } = extAttr;\n    extAttr.tokens.name.value = renamedLegacies.get(name);\n    if (name === \"TreatNullAs\") {\n      extAttr.params.tokens = {};\n    }\n  };\n}\n\n// Note: we parse something simpler than the official syntax. It's all that ever\n// seems to be used\nexport class ExtendedAttributes extends ArrayBase {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const tokens = {};\n    tokens.open = tokeniser.consume(\"[\");\n    if (!tokens.open) return new ExtendedAttributes({});\n    const ret = new ExtendedAttributes({ source: tokeniser.source, tokens });\n    ret.push(...list(tokeniser, {\n      parser: SimpleExtendedAttribute.parse,\n      listName: \"extended attribute\"\n    }));\n    tokens.close = tokeniser.consume(\"]\") || tokeniser.error(\"Unexpected closing token of extended attribute\");\n    if (!ret.length) {\n      tokeniser.error(\"Found an empty extended attribute\");\n    }\n    if (tokeniser.probe(\"[\")) {\n      tokeniser.error(\"Illegal double extended attribute lists, consider merging them\");\n    }\n    return ret;\n  }\n\n  *validate(defs) {\n    for (const extAttr of this) {\n      yield* extAttr.validate(defs);\n    }\n  }\n}\n","import { Base } from \"./base.js\";\nimport { unescape, type_with_extended_attributes, return_type, primitive_type, autoParenter } from \"./helpers.js\";\nimport { stringTypes, typeNameKeywords } from \"../tokeniser.js\";\nimport { validationError } from \"../error.js\";\nimport { idlTypeIncludesDictionary } from \"../validators/helpers.js\";\nimport { ExtendedAttributes } from \"./extended-attributes.js\";\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} typeName\n */\nfunction generic_type(tokeniser, typeName) {\n  const base = tokeniser.consume(\"FrozenArray\", \"ObservableArray\", \"Promise\", \"sequence\", \"record\");\n  if (!base) {\n    return;\n  }\n  const ret = autoParenter(new Type({ source: tokeniser.source, tokens: { base } }));\n  ret.tokens.open = tokeniser.consume(\"<\") || tokeniser.error(`No opening bracket after ${base.type}`);\n  switch (base.type) {\n    case \"Promise\": {\n      if (tokeniser.probe(\"[\")) tokeniser.error(\"Promise type cannot have extended attribute\");\n      const subtype = return_type(tokeniser, typeName) || tokeniser.error(\"Missing Promise subtype\");\n      ret.subtype.push(subtype);\n      break;\n    }\n    case \"sequence\":\n    case \"FrozenArray\":\n    case \"ObservableArray\": {\n      const subtype = type_with_extended_attributes(tokeniser, typeName) || tokeniser.error(`Missing ${base.type} subtype`);\n      ret.subtype.push(subtype);\n      break;\n    }\n    case \"record\": {\n      if (tokeniser.probe(\"[\")) tokeniser.error(\"Record key cannot have extended attribute\");\n      const keyType = tokeniser.consume(...stringTypes) || tokeniser.error(`Record key must be one of: ${stringTypes.join(\", \")}`);\n      const keyIdlType = new Type({ source: tokeniser.source, tokens: { base: keyType }});\n      keyIdlType.tokens.separator = tokeniser.consume(\",\") || tokeniser.error(\"Missing comma after record key type\");\n      keyIdlType.type = typeName;\n      const valueType = type_with_extended_attributes(tokeniser, typeName) || tokeniser.error(\"Error parsing generic type record\");\n      ret.subtype.push(keyIdlType, valueType);\n      break;\n    }\n  }\n  if (!ret.idlType) tokeniser.error(`Error parsing generic type ${base.type}`);\n  ret.tokens.close = tokeniser.consume(\">\") || tokeniser.error(`Missing closing bracket after ${base.type}`);\n  return ret.this;\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nfunction type_suffix(tokeniser, obj) {\n  const nullable = tokeniser.consume(\"?\");\n  if (nullable) {\n    obj.tokens.nullable = nullable;\n  }\n  if (tokeniser.probe(\"?\")) tokeniser.error(\"Can't nullable more than once\");\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} typeName\n */\nfunction single_type(tokeniser, typeName) {\n  let ret = generic_type(tokeniser, typeName) || primitive_type(tokeniser);\n  if (!ret) {\n    const base = tokeniser.consume(\"identifier\", ...stringTypes, ...typeNameKeywords);\n    if (!base) {\n      return;\n    }\n    ret = new Type({ source: tokeniser.source, tokens: { base } });\n    if (tokeniser.probe(\"<\")) tokeniser.error(`Unsupported generic type ${base.value}`);\n  }\n  if (ret.generic === \"Promise\" && tokeniser.probe(\"?\")) {\n    tokeniser.error(\"Promise type cannot be nullable\");\n  }\n  ret.type = typeName || null;\n  type_suffix(tokeniser, ret);\n  if (ret.nullable && ret.idlType === \"any\") tokeniser.error(\"Type `any` cannot be made nullable\");\n  return ret;\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} type\n */\nfunction union_type(tokeniser, type) {\n  const tokens = {};\n  tokens.open = tokeniser.consume(\"(\");\n  if (!tokens.open) return;\n  const ret = autoParenter(new Type({ source: tokeniser.source, tokens }));\n  ret.type = type || null;\n  while (true) {\n    const typ = type_with_extended_attributes(tokeniser) || tokeniser.error(\"No type after open parenthesis or 'or' in union type\");\n    if (typ.idlType === \"any\") tokeniser.error(\"Type `any` cannot be included in a union type\");\n    if (typ.generic === \"Promise\") tokeniser.error(\"Type `Promise` cannot be included in a union type\");\n    ret.subtype.push(typ);\n    const or = tokeniser.consume(\"or\");\n    if (or) {\n      typ.tokens.separator = or;\n    }\n    else break;\n  }\n  if (ret.idlType.length < 2) {\n    tokeniser.error(\"At least two types are expected in a union type but found less\");\n  }\n  tokens.close = tokeniser.consume(\")\") || tokeniser.error(\"Unterminated union type\");\n  type_suffix(tokeniser, ret);\n  return ret.this;\n}\n\nexport class Type extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   * @param {string} typeName\n   */\n  static parse(tokeniser, typeName) {\n    return single_type(tokeniser, typeName) || union_type(tokeniser, typeName);\n  }\n\n  constructor({ source, tokens }) {\n    super({ source, tokens });\n    Object.defineProperty(this, \"subtype\", { value: [], writable: true });\n    this.extAttrs = new ExtendedAttributes({});\n  }\n\n  get generic() {\n    if (this.subtype.length && this.tokens.base) {\n      return this.tokens.base.value;\n    }\n    return \"\";\n  }\n  get nullable() {\n    return Boolean(this.tokens.nullable);\n  }\n  get union() {\n    return Boolean(this.subtype.length) && !this.tokens.base;\n  }\n  get idlType() {\n    if (this.subtype.length) {\n      return this.subtype;\n    }\n    // Adding prefixes/postfixes for \"unrestricted float\", etc.\n    const name = [\n      this.tokens.prefix,\n      this.tokens.base,\n      this.tokens.postfix\n    ].filter(t => t).map(t => t.value).join(\" \");\n    return unescape(name);\n  }\n\n  *validate(defs) {\n    yield* this.extAttrs.validate(defs);\n\n    if (this.idlType === \"void\") {\n      const message = `\\`void\\` is now replaced by \\`undefined\\`. Refer to the \\\n[relevant GitHub issue](https://github.com/heycam/webidl/issues/60) \\\nfor more information.`;\n      yield validationError(this.tokens.base, this, \"replace-void\", message, {\n        autofix: replaceVoid(this)\n      });\n    }\n\n    /*\n     * If a union is nullable, its subunions cannot include a dictionary\n     * If not, subunions may include dictionaries if each union is not nullable\n     */\n    const typedef = !this.union && defs.unique.get(this.idlType);\n    const target =\n      this.union ? this :\n      (typedef && typedef.type === \"typedef\") ? typedef.idlType :\n      undefined;\n    if (target && this.nullable) {\n      // do not allow any dictionary\n      const { reference } = idlTypeIncludesDictionary(target, defs) || {};\n      if (reference) {\n        const targetToken = (this.union ? reference : this).tokens.base;\n        const message = \"Nullable union cannot include a dictionary type.\";\n        yield validationError(targetToken, this, \"no-nullable-union-dict\", message);\n      }\n    } else {\n      // allow some dictionary\n      for (const subtype of this.subtype) {\n        yield* subtype.validate(defs);\n      }\n    }\n  }\n}\n\n/**\n * @param {Type} type\n */\nfunction replaceVoid(type) {\n  return () => {\n    type.tokens.base.value = \"undefined\";\n  };\n}\n","import { Base } from \"./base.js\";\nimport { const_data, const_value } from \"./helpers.js\";\n\nexport class Default extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const assign = tokeniser.consume(\"=\");\n    if (!assign) {\n      return null;\n    }\n    const def = const_value(tokeniser) || tokeniser.consume(\"string\", \"null\", \"[\", \"{\") || tokeniser.error(\"No value for default\");\n    const expression = [def];\n    if (def.type === \"[\") {\n      const close = tokeniser.consume(\"]\") || tokeniser.error(\"Default sequence value must be empty\");\n      expression.push(close);\n    } else if (def.type === \"{\") {\n      const close = tokeniser.consume(\"}\") || tokeniser.error(\"Default dictionary value must be empty\");\n      expression.push(close);\n    }\n    return new Default({ source: tokeniser.source, tokens: { assign }, expression });\n  }\n\n  constructor({ source, tokens, expression }) {\n    super({ source, tokens });\n    expression.parent = this;\n    Object.defineProperty(this, \"expression\", { value: expression });\n  }\n\n  get type() {\n    return const_data(this.expression[0]).type;\n  }\n  get value() {\n    return const_data(this.expression[0]).value;\n  }\n  get negative() {\n    return const_data(this.expression[0]).negative;\n  }\n}\n","// @ts-check\n\nimport { Base } from \"./base.js\";\nimport { Default } from \"./default.js\";\nimport { ExtendedAttributes } from \"./extended-attributes.js\";\nimport { unescape, type_with_extended_attributes, autoParenter, getFirstToken } from \"./helpers.js\";\nimport { argumentNameKeywords, Tokeniser } from \"../tokeniser.js\";\nimport { validationError } from \"../error.js\";\nimport { idlTypeIncludesDictionary, dictionaryIncludesRequiredField } from \"../validators/helpers.js\";\n\nexport class Argument extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const start_position = tokeniser.position;\n    /** @type {Base[\"tokens\"]} */\n    const tokens = {};\n    const ret = autoParenter(new Argument({ source: tokeniser.source, tokens }));\n    ret.extAttrs = ExtendedAttributes.parse(tokeniser);\n    tokens.optional = tokeniser.consume(\"optional\");\n    ret.idlType = type_with_extended_attributes(tokeniser, \"argument-type\");\n    if (!ret.idlType) {\n      return tokeniser.unconsume(start_position);\n    }\n    if (!tokens.optional) {\n      tokens.variadic = tokeniser.consume(\"...\");\n    }\n    tokens.name = tokeniser.consume(\"identifier\", ...argumentNameKeywords);\n    if (!tokens.name) {\n      return tokeniser.unconsume(start_position);\n    }\n    ret.default = tokens.optional ? Default.parse(tokeniser) : null;\n    return ret.this;\n  }\n\n  get type() {\n    return \"argument\";\n  }\n  get optional() {\n    return !!this.tokens.optional;\n  }\n  get variadic() {\n    return !!this.tokens.variadic;\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n\n  /**\n   * @param {import(\"../validator.js\").Definitions} defs\n   */\n  *validate(defs) {\n    yield* this.idlType.validate(defs);\n    const result = idlTypeIncludesDictionary(this.idlType, defs, { useNullableInner: true });\n    if (result) {\n      if (this.idlType.nullable) {\n        const message = `Dictionary arguments cannot be nullable.`;\n        yield validationError(this.tokens.name, this, \"no-nullable-dict-arg\", message);\n      } else if (!this.optional) {\n        if (this.parent && !dictionaryIncludesRequiredField(result.dictionary, defs) && isLastRequiredArgument(this)) {\n          const message = `Dictionary argument must be optional if it has no required fields`;\n          yield validationError(this.tokens.name, this, \"dict-arg-optional\", message, {\n            autofix: autofixDictionaryArgumentOptionality(this)\n          });\n        }\n      } else if (!this.default) {\n        const message = `Optional dictionary arguments must have a default value of \\`{}\\`.`;\n        yield validationError(this.tokens.name, this, \"dict-arg-default\", message, {\n          autofix: autofixOptionalDictionaryDefaultValue(this)\n        });\n      }\n    }\n  }\n}\n\n/**\n * @param {Argument} arg\n */\nfunction isLastRequiredArgument(arg) {\n  const list = arg.parent.arguments || arg.parent.list;\n  const index = list.indexOf(arg);\n  const requiredExists = list.slice(index + 1).some(a => !a.optional);\n  return !requiredExists;\n}\n\n/**\n * @param {Argument} arg\n */\nfunction autofixDictionaryArgumentOptionality(arg) {\n  return () => {\n    const firstToken = getFirstToken(arg.idlType);\n    arg.tokens.optional = { type: \"optional\", value: \"optional\", trivia: firstToken.trivia };\n    firstToken.trivia = \" \";\n    autofixOptionalDictionaryDefaultValue(arg)();\n  };\n}\n\n/**\n * @param {Argument} arg\n */\nfunction autofixOptionalDictionaryDefaultValue(arg) {\n  return () => {\n    arg.default = Default.parse(new Tokeniser(\" = {}\"));\n  };\n}\n","import { Base } from \"./base.js\";\nimport { return_type, argument_list, unescape, autoParenter } from \"./helpers.js\";\nimport { validationError } from \"../error.js\";\n\nexport class Operation extends Base {\n  /**\n   * @typedef {import(\"../tokeniser.js\").Token} Token\n   *\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   * @param {object} [options]\n   * @param {Token} [options.special]\n   * @param {Token} [options.regular]\n   */\n  static parse(tokeniser, { special, regular } = {}) {\n    const tokens = { special };\n    const ret = autoParenter(new Operation({ source: tokeniser.source, tokens }));\n    if (special && special.value === \"stringifier\") {\n      tokens.termination = tokeniser.consume(\";\");\n      if (tokens.termination) {\n        ret.arguments = [];\n        return ret;\n      }\n    }\n    if (!special && !regular) {\n      tokens.special = tokeniser.consume(\"getter\", \"setter\", \"deleter\");\n    }\n    ret.idlType = return_type(tokeniser) || tokeniser.error(\"Missing return type\");\n    tokens.name = tokeniser.consume(\"identifier\", \"includes\");\n    tokens.open = tokeniser.consume(\"(\") || tokeniser.error(\"Invalid operation\");\n    ret.arguments = argument_list(tokeniser);\n    tokens.close = tokeniser.consume(\")\") || tokeniser.error(\"Unterminated operation\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated operation, expected `;`\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"operation\";\n  }\n  get name() {\n    const { name } = this.tokens;\n    if (!name) {\n      return \"\";\n    }\n    return unescape(name.value);\n  }\n  get special() {\n    if (!this.tokens.special) {\n      return \"\";\n    }\n    return this.tokens.special.value;\n  }\n\n  *validate(defs) {\n    if (!this.name && [\"\", \"static\"].includes(this.special)) {\n      const message = `Regular or static operations must have both a return type and an identifier.`;\n      yield validationError(this.tokens.open, this, \"incomplete-op\", message);\n    }\n    if (this.idlType) {\n      yield* this.idlType.validate(defs);\n    }\n    for (const argument of this.arguments) {\n      yield* argument.validate(defs);\n    }\n  }\n}\n","import { Base } from \"./base.js\";\nimport { type_with_extended_attributes, unescape, autoParenter } from \"./helpers.js\";\n\nexport class Attribute extends Base {\n  /**\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser, { special, noInherit = false, readonly = false } = {}) {\n    const start_position = tokeniser.position;\n    const tokens = { special };\n    const ret = autoParenter(new Attribute({ source: tokeniser.source, tokens }));\n    if (!special && !noInherit) {\n      tokens.special = tokeniser.consume(\"inherit\");\n    }\n    if (ret.special === \"inherit\" && tokeniser.probe(\"readonly\")) {\n      tokeniser.error(\"Inherited attributes cannot be read-only\");\n    }\n    tokens.readonly = tokeniser.consume(\"readonly\");\n    if (readonly && !tokens.readonly && tokeniser.probe(\"attribute\")) {\n      tokeniser.error(\"Attributes must be readonly in this context\");\n    }\n    tokens.base = tokeniser.consume(\"attribute\");\n    if (!tokens.base) {\n      tokeniser.unconsume(start_position);\n      return;\n    }\n    ret.idlType = type_with_extended_attributes(tokeniser, \"attribute-type\") || tokeniser.error(\"Attribute lacks a type\");\n    switch (ret.idlType.generic) {\n      case \"sequence\":\n      case \"record\": tokeniser.error(`Attributes cannot accept ${ret.idlType.generic} types`);\n    }\n    tokens.name = tokeniser.consume(\"identifier\", \"async\", \"required\") || tokeniser.error(\"Attribute lacks a name\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated attribute, expected `;`\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"attribute\";\n  }\n  get special() {\n    if (!this.tokens.special) {\n      return \"\";\n    }\n    return this.tokens.special.value;\n  }\n  get readonly() {\n    return !!this.tokens.readonly;\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n\n  *validate(defs) {\n    yield* this.extAttrs.validate(defs);\n    yield* this.idlType.validate(defs);\n  }\n}\n","import { Type } from \"./type.js\";\nimport { Argument } from \"./argument.js\";\nimport { ExtendedAttributes, SimpleExtendedAttribute } from \"./extended-attributes.js\";\nimport { Operation } from \"./operation.js\";\nimport { Attribute } from \"./attribute.js\";\nimport { Tokeniser } from \"../tokeniser.js\";\n\n/**\n * @param {string} identifier\n */\nexport function unescape(identifier) {\n  return identifier.startsWith('_') ? identifier.slice(1) : identifier;\n}\n\n/**\n * Parses comma-separated list\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {object} args\n * @param {Function} args.parser parser function for each item\n * @param {boolean} [args.allowDangler] whether to allow dangling comma\n * @param {string} [args.listName] the name to be shown on error messages\n */\nexport function list(tokeniser, { parser, allowDangler, listName = \"list\" }) {\n  const first = parser(tokeniser);\n  if (!first) {\n    return [];\n  }\n  first.tokens.separator = tokeniser.consume(\",\");\n  const items = [first];\n  while (first.tokens.separator) {\n    const item = parser(tokeniser);\n    if (!item) {\n      if (!allowDangler) {\n        tokeniser.error(`Trailing comma in ${listName}`);\n      }\n      break;\n    }\n    item.tokens.separator = tokeniser.consume(\",\");\n    items.push(item);\n    if (!item.tokens.separator) break;\n  }\n  return items;\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nexport function const_value(tokeniser) {\n  return tokeniser.consume(\"true\", \"false\", \"Infinity\", \"-Infinity\", \"NaN\", \"decimal\", \"integer\");\n}\n\n/**\n * @param {object} token\n * @param {string} token.type\n * @param {string} token.value\n */\nexport function const_data({ type, value }) {\n  switch (type) {\n    case \"true\":\n    case \"false\":\n      return { type: \"boolean\", value: type === \"true\" };\n    case \"Infinity\":\n    case \"-Infinity\":\n      return { type: \"Infinity\", negative: type.startsWith(\"-\") };\n    case \"[\":\n      return { type: \"sequence\", value: [] };\n    case \"{\":\n      return { type: \"dictionary\" };\n    case \"decimal\":\n    case \"integer\":\n      return { type: \"number\", value };\n    case \"string\":\n      return { type: \"string\", value: value.slice(1, -1) };\n    default:\n      return { type };\n  }\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nexport function primitive_type(tokeniser) {\n  function integer_type() {\n    const prefix = tokeniser.consume(\"unsigned\");\n    const base = tokeniser.consume(\"short\", \"long\");\n    if (base) {\n      const postfix = tokeniser.consume(\"long\");\n      return new Type({ source, tokens: { prefix, base, postfix } });\n    }\n    if (prefix) tokeniser.error(\"Failed to parse integer type\");\n  }\n\n  function decimal_type() {\n    const prefix = tokeniser.consume(\"unrestricted\");\n    const base = tokeniser.consume(\"float\", \"double\");\n    if (base) {\n      return new Type({ source, tokens: { prefix, base } });\n    }\n    if (prefix) tokeniser.error(\"Failed to parse float type\");\n  }\n\n  const { source } = tokeniser;\n  const num_type = integer_type(tokeniser) || decimal_type(tokeniser);\n  if (num_type) return num_type;\n  const base = tokeniser.consume(\"bigint\", \"boolean\", \"byte\", \"octet\", \"undefined\");\n  if (base) {\n    return new Type({ source, tokens: { base } });\n  }\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nexport function argument_list(tokeniser) {\n  return list(tokeniser, { parser: Argument.parse, listName: \"arguments list\" });\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} typeName\n */\nexport function type_with_extended_attributes(tokeniser, typeName) {\n  const extAttrs = ExtendedAttributes.parse(tokeniser);\n  const ret = Type.parse(tokeniser, typeName);\n  if (ret) autoParenter(ret).extAttrs = extAttrs;\n  return ret;\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n * @param {string} typeName\n */\nexport function return_type(tokeniser, typeName) {\n  const typ = Type.parse(tokeniser, typeName || \"return-type\");\n  if (typ) {\n    return typ;\n  }\n  const voidToken = tokeniser.consume(\"void\");\n  if (voidToken) {\n    const ret = new Type({ source: tokeniser.source, tokens: { base: voidToken } });\n    ret.type = \"return-type\";\n    return ret;\n  }\n}\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nexport function stringifier(tokeniser) {\n  const special = tokeniser.consume(\"stringifier\");\n  if (!special) return;\n  const member = Attribute.parse(tokeniser, { special }) ||\n    Operation.parse(tokeniser, { special }) ||\n    tokeniser.error(\"Unterminated stringifier\");\n  return member;\n}\n\n/**\n * @param {string} str\n */\nexport function getLastIndentation(str) {\n  const lines = str.split(\"\\n\");\n  // the first line visually binds to the preceding token\n  if (lines.length) {\n    const match = lines[lines.length - 1].match(/^\\s+/);\n    if (match) {\n      return match[0];\n    }\n  }\n  return \"\";\n}\n\n/**\n * @param {string} parentTrivia\n */\nexport function getMemberIndentation(parentTrivia) {\n  const indentation = getLastIndentation(parentTrivia);\n  const indentCh = indentation.includes(\"\\t\") ? \"\\t\" : \"  \";\n  return indentation + indentCh;\n}\n\n/**\n * @param {object} def\n * @param {import(\"./extended-attributes.js\").ExtendedAttributes} def.extAttrs\n */\nexport function autofixAddExposedWindow(def) {\n  return () => {\n    if (def.extAttrs.length){\n      const tokeniser = new Tokeniser(\"Exposed=Window,\");\n      const exposed = SimpleExtendedAttribute.parse(tokeniser);\n      exposed.tokens.separator = tokeniser.consume(\",\");\n      const existing = def.extAttrs[0];\n      if (!/^\\s/.test(existing.tokens.name.trivia)) {\n        existing.tokens.name.trivia = ` ${existing.tokens.name.trivia}`;\n      }\n      def.extAttrs.unshift(exposed);\n    } else {\n      autoParenter(def).extAttrs = ExtendedAttributes.parse(new Tokeniser(\"[Exposed=Window]\"));\n      const trivia = def.tokens.base.trivia;\n      def.extAttrs.tokens.open.trivia = trivia;\n      def.tokens.base.trivia = `\\n${getLastIndentation(trivia)}`;\n    }\n  };\n}\n\n/**\n * Get the first syntax token for the given IDL object.\n * @param {*} data\n */\nexport function getFirstToken(data) {\n  if (data.extAttrs.length) {\n    return data.extAttrs.tokens.open;\n  }\n  if (data.type === \"operation\" && !data.special) {\n    return getFirstToken(data.idlType);\n  }\n  const tokens = Object.values(data.tokens).sort((x, y) => x.index - y.index);\n  return tokens[0];\n}\n\n/**\n * @template T\n * @param {T[]} array\n * @param {(item: T) => boolean} predicate\n */\nexport function findLastIndex(array, predicate) {\n  const index = array.slice().reverse().findIndex(predicate);\n  if (index === -1) {\n    return index;\n  }\n  return array.length - index - 1;\n}\n\n/**\n * Returns a proxy that auto-assign `parent` field.\n * @template T\n * @param {T} data\n * @param {*} [parent] The object that will be assigned to `parent`.\n *                     If absent, it will be `data` by default.\n * @return {T}\n */\nexport function autoParenter(data, parent) {\n  if (!parent) {\n    // Defaults to `data` unless specified otherwise.\n    parent = data;\n  }\n  if (!data) {\n    // This allows `autoParenter(undefined)` which again allows\n    // `autoParenter(parse())` where the function may return nothing.\n    return data;\n  }\n  return new Proxy(data, {\n    get(target, p) {\n      const value = target[p];\n      if (Array.isArray(value)) {\n        // Wraps the array so that any added items will also automatically\n        // get their `parent` values.\n        return autoParenter(value, target);\n      }\n      return value;\n    },\n    set(target, p, value) {\n      target[p] = value;\n      if (!value) {\n        return true;\n      } else if (Array.isArray(value)) {\n        // Assigning an array will add `parent` to its items.\n        for (const item of value) {\n          if (typeof item.parent !== \"undefined\") {\n            item.parent = parent;\n          }\n        }\n      } else if (typeof value.parent !== \"undefined\") {\n        value.parent = parent;\n      }\n      return true;\n    }\n  });\n}\n","import { syntaxError } from \"./error.js\";\nimport { unescape } from \"./productions/helpers.js\";\n\n// These regular expressions use the sticky flag so they will only match at\n// the current location (ie. the offset of lastIndex).\nconst tokenRe = {\n  // This expression uses a lookahead assertion to catch false matches\n  // against integers early.\n  \"decimal\": /-?(?=[0-9]*\\.|[0-9]+[eE])(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y,\n  \"integer\": /-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y,\n  \"identifier\": /[_-]?[A-Za-z][0-9A-Z_a-z-]*/y,\n  \"string\": /\"[^\"]*\"/y,\n  \"whitespace\": /[\\t\\n\\r ]+/y,\n  \"comment\": /((\\/(\\/.*|\\*([^*]|\\*[^/])*\\*\\/)[\\t\\n\\r ]*)+)/y,\n  \"other\": /[^\\t\\n\\r 0-9A-Za-z]/y\n};\n\nexport const typeNameKeywords = [\n  \"ArrayBuffer\",\n  \"DataView\",\n  \"Int8Array\",\n  \"Int16Array\",\n  \"Int32Array\",\n  \"Uint8Array\",\n  \"Uint16Array\",\n  \"Uint32Array\",\n  \"Uint8ClampedArray\",\n  \"Float32Array\",\n  \"Float64Array\",\n  \"any\",\n  \"object\",\n  \"symbol\"\n];\n\nexport const stringTypes = [\n  \"ByteString\",\n  \"DOMString\",\n  \"USVString\"\n];\n\nexport const argumentNameKeywords = [\n  \"async\",\n  \"attribute\",\n  \"callback\",\n  \"const\",\n  \"constructor\",\n  \"deleter\",\n  \"dictionary\",\n  \"enum\",\n  \"getter\",\n  \"includes\",\n  \"inherit\",\n  \"interface\",\n  \"iterable\",\n  \"maplike\",\n  \"namespace\",\n  \"partial\",\n  \"required\",\n  \"setlike\",\n  \"setter\",\n  \"static\",\n  \"stringifier\",\n  \"typedef\",\n  \"unrestricted\"\n];\n\nconst nonRegexTerminals = [\n  \"-Infinity\",\n  \"FrozenArray\",\n  \"Infinity\",\n  \"NaN\",\n  \"ObservableArray\",\n  \"Promise\",\n  \"bigint\",\n  \"boolean\",\n  \"byte\",\n  \"double\",\n  \"false\",\n  \"float\",\n  \"long\",\n  \"mixin\",\n  \"null\",\n  \"octet\",\n  \"optional\",\n  \"or\",\n  \"readonly\",\n  \"record\",\n  \"sequence\",\n  \"short\",\n  \"true\",\n  \"undefined\",\n  \"unsigned\",\n  \"void\"\n].concat(argumentNameKeywords, stringTypes, typeNameKeywords);\n\nconst punctuations = [\n  \"(\",\n  \")\",\n  \",\",\n  \"...\",\n  \":\",\n  \";\",\n  \"<\",\n  \"=\",\n  \">\",\n  \"?\",\n  \"[\",\n  \"]\",\n  \"{\",\n  \"}\"\n];\n\nconst reserved = [\n  // \"constructor\" is now a keyword\n  \"_constructor\",\n  \"toString\",\n  \"_toString\",\n];\n\n/**\n * @typedef {ArrayItemType<ReturnType<typeof tokenise>>} Token\n * @param {string} str\n */\nfunction tokenise(str) {\n  const tokens = [];\n  let lastCharIndex = 0;\n  let trivia = \"\";\n  let line = 1;\n  let index = 0;\n  while (lastCharIndex < str.length) {\n    const nextChar = str.charAt(lastCharIndex);\n    let result = -1;\n\n    if (/[\\t\\n\\r ]/.test(nextChar)) {\n      result = attemptTokenMatch(\"whitespace\", { noFlushTrivia: true });\n    } else if (nextChar === '/') {\n      result = attemptTokenMatch(\"comment\", { noFlushTrivia: true });\n    }\n\n    if (result !== -1) {\n      const currentTrivia = tokens.pop().value;\n      line += (currentTrivia.match(/\\n/g) || []).length;\n      trivia += currentTrivia;\n      index -= 1;\n    } else if (/[-0-9.A-Z_a-z]/.test(nextChar)) {\n      result = attemptTokenMatch(\"decimal\");\n      if (result === -1) {\n        result = attemptTokenMatch(\"integer\");\n      }\n      if (result === -1) {\n        result = attemptTokenMatch(\"identifier\");\n        const lastIndex = tokens.length - 1;\n        const token = tokens[lastIndex];\n        if (result !== -1) {\n          if (reserved.includes(token.value)) {\n            const message = `${unescape(token.value)} is a reserved identifier and must not be used.`;\n            throw new WebIDLParseError(syntaxError(tokens, lastIndex, null, message));\n          } else if (nonRegexTerminals.includes(token.value)) {\n            token.type = token.value;\n          }\n        }\n      }\n    } else if (nextChar === '\"') {\n      result = attemptTokenMatch(\"string\");\n    }\n\n    for (const punctuation of punctuations) {\n      if (str.startsWith(punctuation, lastCharIndex)) {\n        tokens.push({ type: punctuation, value: punctuation, trivia, line, index });\n        trivia = \"\";\n        lastCharIndex += punctuation.length;\n        result = lastCharIndex;\n        break;\n      }\n    }\n\n    // other as the last try\n    if (result === -1) {\n      result = attemptTokenMatch(\"other\");\n    }\n    if (result === -1) {\n      throw new Error(\"Token stream not progressing\");\n    }\n    lastCharIndex = result;\n    index += 1;\n  }\n\n  // remaining trivia as eof\n  tokens.push({\n    type: \"eof\",\n    value: \"\",\n    trivia\n  });\n\n  return tokens;\n\n  /**\n   * @param {keyof typeof tokenRe} type\n   * @param {object} options\n   * @param {boolean} [options.noFlushTrivia]\n   */\n  function attemptTokenMatch(type, { noFlushTrivia } = {}) {\n    const re = tokenRe[type];\n    re.lastIndex = lastCharIndex;\n    const result = re.exec(str);\n    if (result) {\n      tokens.push({ type, value: result[0], trivia, line, index });\n      if (!noFlushTrivia) {\n        trivia = \"\";\n      }\n      return re.lastIndex;\n    }\n    return -1;\n  }\n}\n\nexport class Tokeniser {\n  /**\n   * @param {string} idl\n   */\n  constructor(idl) {\n    this.source = tokenise(idl);\n    this.position = 0;\n  }\n\n  /**\n   * @param {string} message\n   * @return {never}\n   */\n  error(message) {\n    throw new WebIDLParseError(syntaxError(this.source, this.position, this.current, message));\n  }\n\n  /**\n   * @param {string} type\n   */\n  probe(type) {\n    return this.source.length > this.position && this.source[this.position].type === type;\n  }\n\n  /**\n   * @param  {...string} candidates\n   */\n  consume(...candidates) {\n    for (const type of candidates) {\n      if (!this.probe(type)) continue;\n      const token = this.source[this.position];\n      this.position++;\n      return token;\n    }\n  }\n\n  /**\n   * @param {number} position\n   */\n  unconsume(position) {\n    this.position = position;\n  }\n}\n\nexport class WebIDLParseError extends Error {\n  /**\n   * @param {object} options\n   * @param {string} options.message\n   * @param {string} options.bareMessage\n   * @param {string} options.context\n   * @param {number} options.line\n   * @param {*} options.sourceName\n   * @param {string} options.input\n   * @param {*[]} options.tokens\n   */\n  constructor({ message, bareMessage, context, line, sourceName, input, tokens }) {\n    super(message);\n\n    this.name = \"WebIDLParseError\"; // not to be mangled\n    this.bareMessage = bareMessage;\n    this.context = context;\n    this.line = line;\n    this.sourceName = sourceName;\n    this.input = input;\n    this.tokens = tokens;\n  }\n}\n","import { list, unescape, autoParenter } from \"./helpers.js\";\nimport { Token } from \"./token.js\";\nimport { Base } from \"./base.js\";\n\nclass EnumValue extends Token {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const value = tokeniser.consume(\"string\");\n    if (value) {\n      return new EnumValue({ source: tokeniser.source, tokens: { value } });\n    }\n  }\n\n  get type() {\n    return \"enum-value\";\n  }\n  get value() {\n    return super.value.slice(1, -1);\n  }\n}\n\nexport class Enum extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    /** @type {Base[\"tokens\"]} */\n    const tokens = {};\n    tokens.base = tokeniser.consume(\"enum\");\n    if (!tokens.base) {\n      return;\n    }\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"No name for enum\");\n    const ret = autoParenter(new Enum({ source: tokeniser.source, tokens }));\n    tokeniser.current = ret.this;\n    tokens.open = tokeniser.consume(\"{\") || tokeniser.error(\"Bodyless enum\");\n    ret.values = list(tokeniser, {\n      parser: EnumValue.parse,\n      allowDangler: true,\n      listName: \"enumeration\"\n    });\n    if (tokeniser.probe(\"string\")) {\n      tokeniser.error(\"No comma between enum values\");\n    }\n    tokens.close = tokeniser.consume(\"}\") || tokeniser.error(\"Unexpected value in enum\");\n    if (!ret.values.length) {\n      tokeniser.error(\"No value in enum\");\n    }\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"No semicolon after enum\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"enum\";\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n}\n","// @ts-check\n\nimport { Base } from \"./base.js\";\nimport { unescape } from \"./helpers.js\";\n\nexport class Includes extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const target = tokeniser.consume(\"identifier\");\n    if (!target) {\n      return;\n    }\n    const tokens = { target };\n    tokens.includes = tokeniser.consume(\"includes\");\n    if (!tokens.includes) {\n      tokeniser.unconsume(target.index);\n      return;\n    }\n    tokens.mixin = tokeniser.consume(\"identifier\") || tokeniser.error(\"Incomplete includes statement\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"No terminating ; for includes statement\");\n    return new Includes({ source: tokeniser.source, tokens });\n  }\n\n  get type() {\n    return \"includes\";\n  }\n  get target() {\n    return unescape(this.tokens.target.value);\n  }\n  get includes() {\n    return unescape(this.tokens.mixin.value);\n  }\n}\n","import { Base } from \"./base.js\";\nimport { type_with_extended_attributes, unescape, autoParenter } from \"./helpers.js\";\n\nexport class Typedef extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    /** @type {Base[\"tokens\"]} */\n    const tokens = {};\n    const ret = autoParenter(new Typedef({ source: tokeniser.source, tokens }));\n    tokens.base = tokeniser.consume(\"typedef\");\n    if (!tokens.base) {\n      return;\n    }\n    ret.idlType = type_with_extended_attributes(tokeniser, \"typedef-type\") || tokeniser.error(\"Typedef lacks a type\");\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"Typedef lacks a name\");\n    tokeniser.current = ret.this;\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated typedef, expected `;`\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"typedef\";\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n\n  *validate(defs) {\n    yield* this.idlType.validate(defs);\n  }\n}\n","import { Base } from \"./base.js\";\nimport { return_type, argument_list, unescape, autoParenter } from \"./helpers.js\";\n\nexport class CallbackFunction extends Base {\n  /**\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser, base) {\n    const tokens = { base };\n    const ret = autoParenter(new CallbackFunction({ source: tokeniser.source, tokens }));\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"Callback lacks a name\");\n    tokeniser.current = ret.this;\n    tokens.assign = tokeniser.consume(\"=\") || tokeniser.error(\"Callback lacks an assignment\");\n    ret.idlType = return_type(tokeniser) || tokeniser.error(\"Callback lacks a return type\");\n    tokens.open = tokeniser.consume(\"(\") || tokeniser.error(\"Callback lacks parentheses for arguments\");\n    ret.arguments = argument_list(tokeniser);\n    tokens.close = tokeniser.consume(\")\") || tokeniser.error(\"Unterminated callback\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated callback, expected `;`\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"callback\";\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n\n  *validate(defs) {\n    yield* this.extAttrs.validate(defs);\n    yield* this.idlType.validate(defs);\n  }\n}\n","import { Base } from \"./base.js\";\nimport { ExtendedAttributes } from \"./extended-attributes.js\";\nimport { unescape, autoParenter } from \"./helpers.js\";\n\n/**\n * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n */\nfunction inheritance(tokeniser) {\n  const colon = tokeniser.consume(\":\");\n  if (!colon) {\n    return {};\n  }\n  const inheritance = tokeniser.consume(\"identifier\") || tokeniser.error(\"Inheritance lacks a type\");\n  return { colon, inheritance };\n}\n\nexport class Container extends Base {\n    /**\n     * @template T\n     * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n     * @param {T} instance\n     * @param {*} args\n     */\n    static parse(tokeniser, instance, { type, inheritable, allowedMembers }) {\n      const { tokens } = instance;\n      tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(`Missing name in ${instance.type}`);\n      tokeniser.current = instance;\n      instance = autoParenter(instance);\n      if (inheritable) {\n        Object.assign(tokens, inheritance(tokeniser));\n      }\n      tokens.open = tokeniser.consume(\"{\") || tokeniser.error(`Bodyless ${type}`);\n      instance.members = [];\n      while (true) {\n        tokens.close = tokeniser.consume(\"}\");\n        if (tokens.close) {\n          tokens.termination = tokeniser.consume(\";\") || tokeniser.error(`Missing semicolon after ${type}`);\n          return instance.this;\n        }\n        const ea = ExtendedAttributes.parse(tokeniser);\n        let mem;\n        for (const [parser, ...args] of allowedMembers) {\n          mem = autoParenter(parser(tokeniser, ...args));\n          if (mem) {\n            break;\n          }\n        }\n        if (!mem) {\n          tokeniser.error(\"Unknown member\");\n        }\n        mem.extAttrs = ea;\n        instance.members.push(mem.this);\n      }\n    }\n\n    get partial() {\n      return !!this.tokens.partial;\n    }\n    get name() {\n      return unescape(this.tokens.name.value);\n    }\n    get inheritance() {\n      if (!this.tokens.inheritance) {\n        return null;\n      }\n      return unescape(this.tokens.inheritance.value);\n    }\n\n    *validate(defs) {\n      for (const member of this.members) {\n        if (member.validate) {\n          yield* member.validate(defs);\n        }\n      }\n    }\n  }\n","import { Base } from \"./base.js\";\nimport { Type } from \"./type.js\";\nimport { const_data, const_value, primitive_type, autoParenter, unescape } from \"./helpers.js\";\n\nexport class Constant extends Base {\n  /**\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    /** @type {Base[\"tokens\"]} */\n    const tokens = {};\n    tokens.base = tokeniser.consume(\"const\");\n    if (!tokens.base) {\n      return;\n    }\n    let idlType = primitive_type(tokeniser);\n    if (!idlType) {\n      const base = tokeniser.consume(\"identifier\") || tokeniser.error(\"Const lacks a type\");\n      idlType = new Type({ source: tokeniser.source, tokens: { base } });\n    }\n    if (tokeniser.probe(\"?\")) {\n      tokeniser.error(\"Unexpected nullable constant type\");\n    }\n    idlType.type = \"const-type\";\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"Const lacks a name\");\n    tokens.assign = tokeniser.consume(\"=\") || tokeniser.error(\"Const lacks value assignment\");\n    tokens.value = const_value(tokeniser) || tokeniser.error(\"Const lacks a value\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated const, expected `;`\");\n    const ret = new Constant({ source: tokeniser.source, tokens });\n    autoParenter(ret).idlType = idlType;\n    return ret;\n  }\n\n  get type() {\n    return \"const\";\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n  get value() {\n    return const_data(this.tokens.value);\n  }\n}\n","import { Base } from \"./base.js\";\nimport { type_with_extended_attributes, autoParenter, argument_list } from \"./helpers.js\";\n\nexport class IterableLike extends Base {\n  /**\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const start_position = tokeniser.position;\n    const tokens = {};\n    const ret = autoParenter(new IterableLike({ source: tokeniser.source, tokens }));\n    tokens.readonly = tokeniser.consume(\"readonly\");\n    if (!tokens.readonly) {\n      tokens.async = tokeniser.consume(\"async\");\n    }\n    tokens.base =\n      tokens.readonly ? tokeniser.consume(\"maplike\", \"setlike\") :\n      tokens.async ? tokeniser.consume(\"iterable\") :\n      tokeniser.consume(\"iterable\", \"maplike\", \"setlike\");\n    if (!tokens.base) {\n      tokeniser.unconsume(start_position);\n      return;\n    }\n\n    const { type } = ret;\n    const secondTypeRequired = type === \"maplike\";\n    const secondTypeAllowed = secondTypeRequired || type === \"iterable\";\n    const argumentAllowed = ret.async && type === \"iterable\";\n\n    tokens.open = tokeniser.consume(\"<\") || tokeniser.error(`Missing less-than sign \\`<\\` in ${type} declaration`);\n    const first = type_with_extended_attributes(tokeniser) || tokeniser.error(`Missing a type argument in ${type} declaration`);\n    ret.idlType = [first];\n    ret.arguments = [];\n\n    if (secondTypeAllowed) {\n      first.tokens.separator = tokeniser.consume(\",\");\n      if (first.tokens.separator) {\n        ret.idlType.push(type_with_extended_attributes(tokeniser));\n      }\n      else if (secondTypeRequired) {\n        tokeniser.error(`Missing second type argument in ${type} declaration`);\n      }\n    }\n\n    tokens.close = tokeniser.consume(\">\") || tokeniser.error(`Missing greater-than sign \\`>\\` in ${type} declaration`);\n\n    if (tokeniser.probe(\"(\")) {\n      if (argumentAllowed) {\n        tokens.argsOpen = tokeniser.consume(\"(\");\n        ret.arguments.push(...argument_list(tokeniser));\n        tokens.argsClose = tokeniser.consume(\")\") || tokeniser.error(\"Unterminated async iterable argument list\");\n      } else {\n        tokeniser.error(`Arguments are only allowed for \\`async iterable\\``);\n      }\n    }\n\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(`Missing semicolon after ${type} declaration`);\n\n    return ret.this;\n  }\n\n  get type() {\n    return this.tokens.base.value;\n  }\n  get readonly() {\n    return !!this.tokens.readonly;\n  }\n  get async() {\n    return !!this.tokens.async;\n  }\n\n  *validate(defs) {\n    for (const type of this.idlType) {\n      yield* type.validate(defs);\n    }\n    for (const argument of this.arguments) {\n      yield* argument.validate(defs);\n    }\n  }\n}\n","import { Base } from \"./base.js\";\nimport { argument_list, autoParenter } from \"./helpers.js\";\n\nexport class Constructor extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    const base = tokeniser.consume(\"constructor\");\n    if (!base) {\n      return;\n    }\n    /** @type {Base[\"tokens\"]} */\n    const tokens = { base };\n    tokens.open = tokeniser.consume(\"(\") || tokeniser.error(\"No argument list in constructor\");\n    const args = argument_list(tokeniser);\n    tokens.close = tokeniser.consume(\")\") || tokeniser.error(\"Unterminated constructor\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"No semicolon after constructor\");\n    const ret = new Constructor({ source: tokeniser.source, tokens });\n    autoParenter(ret).arguments = args;\n    return ret;\n  }\n\n  get type() {\n    return \"constructor\";\n  }\n\n  *validate(defs) {\n    if (this.idlType) {\n      yield* this.idlType.validate(defs);\n    }\n    for (const argument of this.arguments) {\n      yield* argument.validate(defs);\n    }\n  }\n}\n","import { Container } from \"./container.js\";\nimport { Attribute } from \"./attribute.js\";\nimport { Operation } from \"./operation.js\";\nimport { Constant } from \"./constant.js\";\nimport { IterableLike } from \"./iterable.js\";\nimport { stringifier, autofixAddExposedWindow, getMemberIndentation, getLastIndentation, getFirstToken, findLastIndex, autoParenter } from \"./helpers.js\";\nimport { validationError } from \"../error.js\";\nimport { checkInterfaceMemberDuplication } from \"../validators/interface.js\";\nimport { Constructor } from \"./constructor.js\";\nimport { Tokeniser } from \"../tokeniser.js\";\nimport { ExtendedAttributes } from \"./extended-attributes.js\";\n\n/**\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n */\nfunction static_member(tokeniser) {\n  const special = tokeniser.consume(\"static\");\n  if (!special) return;\n  const member = Attribute.parse(tokeniser, { special }) ||\n    Operation.parse(tokeniser, { special }) ||\n    tokeniser.error(\"No body in static member\");\n  return member;\n}\n\nexport class Interface extends Container {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser, base, { partial = null } = {}) {\n    const tokens = { partial, base };\n    return Container.parse(tokeniser, new Interface({ source: tokeniser.source, tokens }), {\n      type: \"interface\",\n      inheritable: !partial,\n      allowedMembers: [\n        [Constant.parse],\n        [Constructor.parse],\n        [static_member],\n        [stringifier],\n        [IterableLike.parse],\n        [Attribute.parse],\n        [Operation.parse]\n      ]\n    });\n  }\n\n  get type() {\n    return \"interface\";\n  }\n\n  *validate(defs) {\n    yield* this.extAttrs.validate(defs);\n    if (\n      !this.partial &&\n      this.extAttrs.every(extAttr => extAttr.name !== \"Exposed\")\n    ) {\n      const message = `Interfaces must have \\`[Exposed]\\` extended attribute. \\\nTo fix, add, for example, \\`[Exposed=Window]\\`. Please also consider carefully \\\nif your interface should also be exposed in a Worker scope. Refer to the \\\n[WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) \\\nfor more information.`;\n      yield validationError(this.tokens.name, this, \"require-exposed\", message, {\n        autofix: autofixAddExposedWindow(this)\n      });\n    }\n    const oldConstructors = this.extAttrs.filter(extAttr => extAttr.name === \"Constructor\");\n    for (const constructor of oldConstructors) {\n      const message = `Constructors should now be represented as a \\`constructor()\\` operation on the interface \\\ninstead of \\`[Constructor]\\` extended attribute. Refer to the \\\n[WebIDL spec section on constructor operations](https://heycam.github.io/webidl/#idl-constructors) \\\nfor more information.`;\n      yield validationError(constructor.tokens.name, this, \"constructor-member\", message, {\n        autofix: autofixConstructor(this, constructor)\n      });\n    }\n\n    const isGlobal = this.extAttrs.some(extAttr => extAttr.name === \"Global\");\n    if (isGlobal) {\n      const factoryFunctions = this.extAttrs.filter(extAttr => extAttr.name === \"LegacyFactoryFunction\");\n      for (const named of factoryFunctions) {\n        const message = `Interfaces marked as \\`[Global]\\` cannot have factory functions.`;\n        yield validationError(named.tokens.name, this, \"no-constructible-global\", message);\n      }\n\n      const constructors = this.members.filter(member => member.type === \"constructor\");\n      for (const named of constructors) {\n        const message = `Interfaces marked as \\`[Global]\\` cannot have constructors.`;\n        yield validationError(named.tokens.base, this, \"no-constructible-global\", message);\n      }\n    }\n\n    yield* super.validate(defs);\n    if (!this.partial) {\n      yield* checkInterfaceMemberDuplication(defs, this);\n    }\n  }\n}\n\nfunction autofixConstructor(interfaceDef, constructorExtAttr) {\n  interfaceDef = autoParenter(interfaceDef);\n  return () => {\n    const indentation = getLastIndentation(interfaceDef.extAttrs.tokens.open.trivia);\n    const memberIndent = interfaceDef.members.length ?\n      getLastIndentation(getFirstToken(interfaceDef.members[0]).trivia) :\n      getMemberIndentation(indentation);\n    const constructorOp = Constructor.parse(new Tokeniser(`\\n${memberIndent}constructor();`));\n    constructorOp.extAttrs = new ExtendedAttributes({});\n    autoParenter(constructorOp).arguments = constructorExtAttr.arguments;\n\n    const existingIndex = findLastIndex(interfaceDef.members, m => m.type === \"constructor\");\n    interfaceDef.members.splice(existingIndex + 1, 0, constructorOp);\n\n    const { close }  = interfaceDef.tokens;\n    if (!close.trivia.includes(\"\\n\")) {\n      close.trivia += `\\n${indentation}`;\n    }\n\n    const { extAttrs } = interfaceDef;\n    const index = extAttrs.indexOf(constructorExtAttr);\n    const removed = extAttrs.splice(index, 1);\n    if (!extAttrs.length) {\n      extAttrs.tokens.open = extAttrs.tokens.close = undefined;\n    } else if (extAttrs.length === index) {\n      extAttrs[index - 1].tokens.separator = undefined;\n    } else if (!extAttrs[index].tokens.name.trivia.trim()) {\n      extAttrs[index].tokens.name.trivia = removed[0].tokens.name.trivia;\n    }\n  };\n}\n","// @ts-check\n\nimport { validationError } from \"../error.js\";\n\nexport function* checkInterfaceMemberDuplication(defs, i) {\n  const opNames = new Set(getOperations(i).map(op => op.name));\n  const partials = defs.partials.get(i.name) || [];\n  const mixins = defs.mixinMap.get(i.name) || [];\n  for (const ext of [...partials, ...mixins]) {\n    const additions = getOperations(ext);\n    yield* forEachExtension(additions, opNames, ext, i);\n    for (const addition of additions) {\n      opNames.add(addition.name);\n    }\n  }\n\n  function* forEachExtension(additions, existings, ext, base) {\n    for (const addition of additions) {\n      const { name } = addition;\n      if (name && existings.has(name)) {\n        const message = `The operation \"${name}\" has already been defined for the base interface \"${base.name}\" either in itself or in a mixin`;\n        yield validationError(addition.tokens.name, ext, \"no-cross-overload\", message);\n      }\n    }\n  }\n\n  function getOperations(i) {\n    return i.members\n      .filter(({type}) => type === \"operation\");\n  }\n}\n","import { Container } from \"./container.js\";\nimport { Constant } from \"./constant.js\";\nimport { Attribute } from \"./attribute.js\";\nimport { Operation } from \"./operation.js\";\nimport { stringifier } from \"./helpers.js\";\n\nexport class Mixin extends Container {\n  /**\n   * @typedef {import(\"../tokeniser.js\").Token} Token\n   *\n   * @param {import(\"../tokeniser.js\").Tokeniser} tokeniser\n   * @param {Token} base\n   * @param {object} [options]\n   * @param {Token} [options.partial]\n   */\n  static parse(tokeniser, base, { partial } = {}) {\n    const tokens = { partial, base };\n    tokens.mixin = tokeniser.consume(\"mixin\");\n    if (!tokens.mixin) {\n      return;\n    }\n    return Container.parse(tokeniser, new Mixin({ source: tokeniser.source, tokens }), {\n      type: \"interface mixin\",\n      allowedMembers: [\n        [Constant.parse],\n        [stringifier],\n        [Attribute.parse, { noInherit: true }],\n        [Operation.parse, { regular: true }]\n      ]\n    });\n  }\n\n  get type() {\n    return \"interface mixin\";\n  }\n}\n","import { Base } from \"./base.js\";\nimport { unescape, type_with_extended_attributes, autoParenter } from \"./helpers.js\";\nimport { ExtendedAttributes } from \"./extended-attributes.js\";\nimport { Default } from \"./default.js\";\n\nexport class Field extends Base {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser) {\n    /** @type {Base[\"tokens\"]} */\n    const tokens = {};\n    const ret = autoParenter(new Field({ source: tokeniser.source, tokens }));\n    ret.extAttrs = ExtendedAttributes.parse(tokeniser);\n    tokens.required = tokeniser.consume(\"required\");\n    ret.idlType = type_with_extended_attributes(tokeniser, \"dictionary-type\") || tokeniser.error(\"Dictionary member lacks a type\");\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"Dictionary member lacks a name\");\n    ret.default = Default.parse(tokeniser);\n    if (tokens.required && ret.default) tokeniser.error(\"Required member must not have a default\");\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"Unterminated dictionary member, expected `;`\");\n    return ret.this;\n  }\n\n  get type() {\n    return \"field\";\n  }\n  get name() {\n    return unescape(this.tokens.name.value);\n  }\n  get required() {\n    return !!this.tokens.required;\n  }\n\n  *validate(defs) {\n    yield* this.idlType.validate(defs);\n  }\n}\n","// @ts-check\n\nimport { Container } from \"./container.js\";\nimport { Field } from \"./field.js\";\n\nexport class Dictionary extends Container {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   * @param {object} [options]\n   * @param {import(\"../tokeniser.js\").Token} [options.partial]\n   */\n  static parse(tokeniser, { partial } = {}) {\n    const tokens = { partial };\n    tokens.base = tokeniser.consume(\"dictionary\");\n    if (!tokens.base) {\n      return;\n    }\n    return Container.parse(tokeniser, new Dictionary({ source: tokeniser.source, tokens }), {\n      type: \"dictionary\",\n      inheritable: !partial,\n      allowedMembers: [\n        [Field.parse],\n      ]\n    });\n  }\n\n  get type() {\n    return \"dictionary\";\n  }\n}\n","import { Container } from \"./container.js\";\nimport { Attribute } from \"./attribute.js\";\nimport { Operation } from \"./operation.js\";\nimport { validationError } from \"../error.js\";\nimport { autofixAddExposedWindow } from \"./helpers.js\";\n\nexport class Namespace extends Container {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   * @param {object} [options]\n   * @param {import(\"../tokeniser.js\").Token} [options.partial]\n   */\n  static parse(tokeniser, { partial } = {}) {\n    const tokens = { partial };\n    tokens.base = tokeniser.consume(\"namespace\");\n    if (!tokens.base) {\n      return;\n    }\n    return Container.parse(tokeniser, new Namespace({ source: tokeniser.source, tokens }), {\n      type: \"namespace\",\n      allowedMembers: [\n        [Attribute.parse, { noInherit: true, readonly: true }],\n        [Operation.parse, { regular: true }]\n      ]\n    });\n  }\n\n  get type() {\n    return \"namespace\";\n  }\n\n  *validate(defs) {\n    if (!this.partial && this.extAttrs.every(extAttr => extAttr.name !== \"Exposed\")) {\n      const message = `Namespaces must have [Exposed] extended attribute. \\\nTo fix, add, for example, [Exposed=Window]. Please also consider carefully \\\nif your namespace should also be exposed in a Worker scope. Refer to the \\\n[WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) \\\nfor more information.`;\n      yield validationError(this.tokens.name, this, \"require-exposed\", message, {\n        autofix: autofixAddExposedWindow(this)\n      });\n    }\n    yield* super.validate(defs);\n  }\n}\n","// @ts-check\n\nimport { Container } from \"./container.js\";\nimport { Operation } from \"./operation.js\";\nimport { Constant } from \"./constant.js\";\n\nexport class CallbackInterface extends Container {\n  /**\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\n   */\n  static parse(tokeniser, callback, { partial = null } = {}) {\n    const tokens = { callback };\n    tokens.base = tokeniser.consume(\"interface\");\n    if (!tokens.base) {\n      return;\n    }\n    return Container.parse(tokeniser, new CallbackInterface({ source: tokeniser.source, tokens }), {\n      type: \"callback interface\",\n      inheritable: !partial,\n      allowedMembers: [\n        [Constant.parse],\n        [Operation.parse, { regular: true }]\n      ]\n    });\n  }\n\n  get type() {\n    return \"callback interface\";\n  }\n}\n","\"use strict\";\n\nimport { Tokeniser } from \"./tokeniser.js\";\nimport { Enum } from \"./productions/enum.js\";\nimport { Includes } from \"./productions/includes.js\";\nimport { ExtendedAttributes } from \"./productions/extended-attributes.js\";\nimport { Typedef } from \"./productions/typedef.js\";\nimport { CallbackFunction } from \"./productions/callback.js\";\nimport { Interface } from \"./productions/interface.js\";\nimport { Mixin } from \"./productions/mixin.js\";\nimport { Dictionary } from \"./productions/dictionary.js\";\nimport { Namespace } from \"./productions/namespace.js\";\nimport { CallbackInterface } from \"./productions/callback-interface.js\";\nimport { autoParenter } from \"./productions/helpers.js\";\n\n/**\n * @param {Tokeniser} tokeniser\n * @param {object} options\n * @param {boolean} [options.concrete]\n */\nfunction parseByTokens(tokeniser, options) {\n  const source = tokeniser.source;\n\n  function error(str) {\n    tokeniser.error(str);\n  }\n\n  function consume(...candidates) {\n    return tokeniser.consume(...candidates);\n  }\n\n  function callback() {\n    const callback = consume(\"callback\");\n    if (!callback) return;\n    if (tokeniser.probe(\"interface\")) {\n      return CallbackInterface.parse(tokeniser, callback);\n    }\n    return CallbackFunction.parse(tokeniser, callback);\n  }\n\n  function interface_(opts) {\n    const base = consume(\"interface\");\n    if (!base) return;\n    const ret = Mixin.parse(tokeniser, base, opts) ||\n      Interface.parse(tokeniser, base, opts) ||\n      error(\"Interface has no proper body\");\n    return ret;\n  }\n\n  function partial() {\n    const partial = consume(\"partial\");\n    if (!partial) return;\n    return Dictionary.parse(tokeniser, { partial }) ||\n      interface_({ partial }) ||\n      Namespace.parse(tokeniser, { partial }) ||\n      error(\"Partial doesn't apply to anything\");\n  }\n\n  function definition() {\n    return callback() ||\n      interface_() ||\n      partial() ||\n      Dictionary.parse(tokeniser) ||\n      Enum.parse(tokeniser) ||\n      Typedef.parse(tokeniser) ||\n      Includes.parse(tokeniser) ||\n      Namespace.parse(tokeniser);\n  }\n\n  function definitions() {\n    if (!source.length) return [];\n    const defs = [];\n    while (true) {\n      const ea = ExtendedAttributes.parse(tokeniser);\n      const def = definition();\n      if (!def) {\n        if (ea.length) error(\"Stray extended attributes\");\n        break;\n      }\n      autoParenter(def).extAttrs = ea;\n      defs.push(def);\n    }\n    const eof = consume(\"eof\");\n    if (options.concrete) {\n      defs.push(eof);\n    }\n    return defs;\n  }\n  const res = definitions();\n  if (tokeniser.position < source.length) error(\"Unrecognised tokens\");\n  return res;\n}\n\n/**\n * @param {string} str\n * @param {object} [options]\n * @param {*} [options.sourceName]\n * @param {boolean} [options.concrete]\n */\nexport function parse(str, options = {}) {\n  const tokeniser = new Tokeniser(str);\n  if (typeof options.sourceName !== \"undefined\") {\n    tokeniser.source.name = options.sourceName;\n  }\n  return parseByTokens(tokeniser, options);\n}\n","\"use strict\";\n\nfunction noop(arg) {\n  return arg;\n}\n\nconst templates = {\n  wrap: items => items.join(\"\"),\n  trivia: noop,\n  name: noop,\n  reference: noop,\n  type: noop,\n  generic: noop,\n  nameless: noop,\n  inheritance: noop,\n  definition: noop,\n  extendedAttribute: noop,\n  extendedAttributeReference: noop\n};\n\nexport function write(ast, { templates: ts = templates } = {}) {\n  ts = Object.assign({}, templates, ts);\n\n  function reference(raw, { unescaped, context }) {\n    if (!unescaped) {\n      unescaped = raw.startsWith(\"_\") ? raw.slice(1) : raw;\n    }\n    return ts.reference(raw, unescaped, context);\n  }\n\n  function token(t, wrapper = noop, ...args) {\n    if (!t) {\n      return \"\";\n    }\n    const value = wrapper(t.value, ...args);\n    return ts.wrap([ts.trivia(t.trivia), value]);\n  }\n\n  function reference_token(t, context) {\n    return token(t, reference, { context });\n  }\n\n  function name_token(t, arg) {\n    return token(t, ts.name, arg);\n  }\n\n  function type_body(it) {\n    if (it.union || it.generic) {\n      return ts.wrap([\n        token(it.tokens.base, ts.generic),\n        token(it.tokens.open),\n        ...it.subtype.map(type),\n        token(it.tokens.close)\n      ]);\n    }\n    const firstToken = it.tokens.prefix || it.tokens.base;\n    const prefix = it.tokens.prefix ? [\n      it.tokens.prefix.value,\n      ts.trivia(it.tokens.base.trivia)\n    ] : [];\n    const ref = reference(ts.wrap([\n      ...prefix,\n      it.tokens.base.value,\n      token(it.tokens.postfix)\n    ]), { unescaped: it.idlType, context: it });\n    return ts.wrap([ts.trivia(firstToken.trivia), ref]);\n  }\n  function type(it) {\n    return ts.wrap([\n      extended_attributes(it.extAttrs),\n      type_body(it),\n      token(it.tokens.nullable),\n      token(it.tokens.separator)\n    ]);\n  }\n  function default_(def) {\n    if (!def) {\n      return \"\";\n    }\n    return ts.wrap([\n      token(def.tokens.assign),\n      ...def.expression.map(t => token(t))\n    ]);\n  }\n  function argument(arg) {\n    return ts.wrap([\n      extended_attributes(arg.extAttrs),\n      token(arg.tokens.optional),\n      ts.type(type(arg.idlType)),\n      token(arg.tokens.variadic),\n      name_token(arg.tokens.name, { data: arg }),\n      default_(arg.default),\n      token(arg.tokens.separator)\n    ]);\n  }\n  function extended_attribute_listitem(str) {\n    return ts.wrap([\n      token(str.tokens.value),\n      token(str.tokens.separator)\n    ]);\n  }\n  function identifier(id, context) {\n    return ts.wrap([\n      reference_token(id.tokens.value, context),\n      token(id.tokens.separator)\n    ]);\n  }\n  function make_ext_at(it) {\n    const { rhsType } = it.params;\n    return ts.wrap([\n      ts.trivia(it.tokens.name.trivia),\n      ts.extendedAttribute(ts.wrap([\n        ts.extendedAttributeReference(it.name),\n        token(it.params.tokens.assign),\n        reference_token(it.params.tokens.secondaryName, it),\n        token(it.params.tokens.open),\n        ...!it.params.list ? [] :\n          it.params.list.map(\n            rhsType === \"identifier-list\" ? id => identifier(id, it) :\n            rhsType && rhsType.endsWith(\"-list\") ? extended_attribute_listitem :\n            argument\n          ),\n        token(it.params.tokens.close)\n      ])),\n      token(it.tokens.separator)\n    ]);\n  }\n  function extended_attributes(eats) {\n    if (!eats.length) return \"\";\n    return ts.wrap([\n      token(eats.tokens.open),\n      ...eats.map(make_ext_at),\n      token(eats.tokens.close)\n    ]);\n  }\n\n  function operation(it, parent) {\n    const body = it.idlType ? [\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      token(it.tokens.open),\n      ts.wrap(it.arguments.map(argument)),\n      token(it.tokens.close),\n    ] : [];\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      it.tokens.name ? token(it.tokens.special) : token(it.tokens.special, ts.nameless, { data: it, parent }),\n      ...body,\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n\n  function attribute(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.special),\n      token(it.tokens.readonly),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n\n  function constructor(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base, ts.nameless, { data: it, parent }),\n      token(it.tokens.open),\n      ts.wrap(it.arguments.map(argument)),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n\n  function inheritance(inh) {\n    if (!inh.tokens.inheritance) {\n      return \"\";\n    }\n    return ts.wrap([\n      token(inh.tokens.colon),\n      ts.trivia(inh.tokens.inheritance.trivia),\n      ts.inheritance(reference(inh.tokens.inheritance.value, { context: inh }))\n    ]);\n  }\n\n  function container(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.callback),\n      token(it.tokens.partial),\n      token(it.tokens.base),\n      token(it.tokens.mixin),\n      name_token(it.tokens.name, { data: it }),\n      inheritance(it),\n      token(it.tokens.open),\n      iterate(it.members, it),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n\n  function field(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.required),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      default_(it.default),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function const_(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      token(it.tokens.assign),\n      token(it.tokens.value),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function typedef(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function includes(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      reference_token(it.tokens.target, it),\n      token(it.tokens.includes),\n      reference_token(it.tokens.mixin, it),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function callback(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.assign),\n      ts.type(type(it.idlType)),\n      token(it.tokens.open),\n      ...it.arguments.map(argument),\n      token(it.tokens.close),\n      token(it.tokens.termination),\n    ]), { data: it });\n  }\n  function enum_(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.open),\n      iterate(it.values, it),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function enum_value(v, parent) {\n    return ts.wrap([\n      ts.trivia(v.tokens.value.trivia),\n      ts.definition(\n        ts.wrap(['\"', ts.name(v.value, { data: v, parent }), '\"']),\n        { data: v, parent }\n      ),\n      token(v.tokens.separator)\n    ]);\n  }\n  function iterable_like(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.readonly),\n      token(it.tokens.async),\n      token(it.tokens.base, ts.generic),\n      token(it.tokens.open),\n      ts.wrap(it.idlType.map(type)),\n      token(it.tokens.close),\n      token(it.tokens.argsOpen),\n      ts.wrap(it.arguments.map(argument)),\n      token(it.tokens.argsClose),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function eof(it) {\n    return ts.trivia(it.trivia);\n  }\n\n  const table = {\n    interface: container,\n    \"interface mixin\": container,\n    namespace: container,\n    operation,\n    attribute,\n    constructor,\n    dictionary: container,\n    field,\n    const: const_,\n    typedef,\n    includes,\n    callback,\n    enum: enum_,\n    \"enum-value\": enum_value,\n    iterable: iterable_like,\n    maplike: iterable_like,\n    setlike: iterable_like,\n    \"callback interface\": container,\n    eof\n  };\n  function dispatch(it, parent) {\n    const dispatcher = table[it.type];\n    if (!dispatcher) {\n      throw new Error(`Type \"${it.type}\" is unsupported`);\n    }\n    return table[it.type](it, parent);\n  }\n  function iterate(things, parent) {\n    if (!things) return;\n    const results = things.map(thing => dispatch(thing, parent));\n    return ts.wrap(results);\n  }\n  return iterate(ast);\n}\n","\"use strict\";\n\nimport { validationError as error } from \"./error.js\";\n\nfunction getMixinMap(all, unique) {\n  const map = new Map();\n  const includes = all.filter(def => def.type === \"includes\");\n  for (const include of includes) {\n    const mixin = unique.get(include.includes);\n    if (!mixin) {\n      continue;\n    }\n    const array = map.get(include.target);\n    if (array) {\n      array.push(mixin);\n    } else {\n      map.set(include.target, [mixin]);\n    }\n  }\n  return map;\n}\n\n/**\n * @typedef {ReturnType<typeof groupDefinitions>} Definitions\n */\nfunction groupDefinitions(all) {\n  const unique = new Map();\n  const duplicates = new Set();\n  const partials = new Map();\n  for (const def of all) {\n    if (def.partial) {\n      const array = partials.get(def.name);\n      if (array) {\n        array.push(def);\n      } else {\n        partials.set(def.name, [def]);\n      }\n      continue;\n    }\n    if (!def.name) {\n      continue;\n    }\n    if (!unique.has(def.name)) {\n      unique.set(def.name, def);\n    } else {\n      duplicates.add(def);\n    }\n  }\n  return {\n    all,\n    unique,\n    partials,\n    duplicates,\n    mixinMap: getMixinMap(all, unique),\n    cache: {\n      typedefIncludesDictionary: new WeakMap(),\n      dictionaryIncludesRequiredField: new WeakMap()\n    },\n  };\n}\n\nfunction* checkDuplicatedNames({ unique, duplicates }) {\n  for (const dup of duplicates) {\n    const { name } = dup;\n    const message = `The name \"${name}\" of type \"${unique.get(name).type}\" was already seen`;\n    yield error(dup.tokens.name, dup, \"no-duplicate\", message);\n  }\n}\n\nfunction* validateIterable(ast) {\n  const defs = groupDefinitions(ast);\n  for (const def of defs.all) {\n    if (def.validate) {\n      yield* def.validate(defs);\n    }\n  }\n  yield* checkDuplicatedNames(defs);\n}\n\n// Remove this once all of our support targets expose `.flat()` by default\nfunction flatten(array) {\n  if (array.flat) {\n    return array.flat();\n  }\n  return [].concat(...array);\n}\n\n/**\n * @param {*} ast AST or array of ASTs\n */\nexport function validate(ast) {\n  return [...validateIterable(flatten(ast))];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(670);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}